# Social Manager — Cursor Project Prompt

## Project Overview

Build a multi-user web application called **"Social Manager"** for managing and publishing social media posts across multiple platforms from a single interface.

The app is built with SvelteKit and can run locally or be deployed to the cloud. It supports multiple users, each with their own brand profiles, platform connections, and post history. Authentication is handled by Better Auth.

---

## Tech Stack

- **Framework:** SvelteKit (latest, with TypeScript)
- **Styling:** Tailwind CSS v4 with @tailwindcss/typography plugin
- **Database:** SQLite via Drizzle ORM + libSQL (switchable to Turso for cloud)
- **Authentication:** Better Auth (`better-auth` package) with email/password. Uses `better-auth/svelte-kit` integration and `sveltekitCookies` plugin.
- **AI:** Multi-provider support — OpenAI-compatible API layer supporting Anthropic, OpenAI, Google, Groq, Mistral, OpenRouter, and local Ollama. App also works fully without AI (manual mode).
- **Icons:** Lucide icons (`lucide-svelte`)
- **Media:** Local file storage in `./data/media/{userId}/`

### Platform Libraries

| Platform   | Package                  | Auth Method                        | Post Limit   |
|------------|--------------------------|-------------------------------------|-------------|
| X/Twitter  | `twitter-api-v2`         | OAuth 1.0a (4 tokens)              | 280 chars   |
| Nostr      | `nostr-tools`            | nsec private key                   | ~unlimited  |
| LinkedIn   | REST API (fetch)         | OAuth 2.0                          | 3000 chars  |
| Bluesky    | `@atproto/api`           | Handle + App Password              | 300 chars   |
| Mastodon   | `masto`                  | Instance URL + Access Token        | 500 chars*  |
| Facebook   | Meta Graph API (fetch)   | Page Access Token (long-lived)     | 63,206 chars|
| Instagram  | Meta Graph API (fetch)   | Same as Facebook (Business account)| 2200 chars  |

*Mastodon limit varies per instance, 500 is default.

**Important platform notes:**
- **Instagram** requires an image with every post (no text-only posts). The app must enforce this in the UI — disable Instagram toggle if no media is attached.
- **Facebook** posts go to a Facebook Page, not a personal profile (API limitation).
- **Bluesky** uses App Passwords (generated in Bluesky Settings), not the account password.
- **Mastodon** requires the user to specify their instance URL (e.g., mastodon.social, bitcoinhackers.org).
- **Nostr** private key must be stored securely. Offer "Generate new keypair" option.

---

## Design Direction

- **Dark theme** as default, with option to switch to light
- **Accent color:** Configurable in settings, default purple (#7c3aed)
- **Typography:** Clean, modern sans-serif (e.g., Geist, Outfit, or similar — NOT Inter/Roboto)
- **Feel:** Developer-friendly, clean, minimal but not boring. Think "premium dev tool"
- **Cards** with subtle borders and glass-morphism effects on dark backgrounds
- **Smooth transitions** between views
- **Responsive** — works on desktop and tablet

---

## Database Schema (Drizzle ORM)

Define in `src/lib/server/db/schema.ts`:

```ts
// ============================================
// AUTH TABLES (generated by Better Auth CLI)
// ============================================
// Run: npx @better-auth/cli generate
// Then merge the generated auth schema into this file.
// Better Auth creates: user, session, account, verification tables.
// Do NOT manually define these — let Better Auth generate them.
// After generation, add any custom columns to the user table if needed.

// ============================================
// APPLICATION TABLES
// ============================================

// Brand profiles — each user can have multiple brands
export const brands = sqliteTable('brands', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),               // References Better Auth user.id
  name: text('name').notNull(),                     // e.g., "SatFlux", "My Blog"
  description: text('description'),                 // Short description of the brand
  voicePrompt: text('voice_prompt').notNull(),      // AI system prompt for brand voice
  isActive: integer('is_active').default(0),        // Currently selected brand for this user
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
});

// Platform connections — per user, per brand
export const platformConnections = sqliteTable('platform_connections', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  brandId: integer('brand_id').references(() => brands.id),
  platform: text('platform').notNull(),             // 'x', 'nostr', 'linkedin', 'bluesky', 'mastodon', 'facebook', 'instagram'
  credentials: text('credentials').notNull(),       // JSON - encrypted platform-specific credentials
  displayName: text('display_name'),                // e.g., "@satflux" or "SatFlux Page"
  isActive: integer('is_active').default(1),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
});

// Posts table
export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  brandId: integer('brand_id').references(() => brands.id),
  originalText: text('original_text').notNull(),
  status: text('status').default('draft'),          // draft, scheduled, published, partial, failed
  scheduledAt: text('scheduled_at'),
  publishedAt: text('published_at'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
  mediaPaths: text('media_paths'),                  // JSON array of file paths
  tags: text('tags'),                               // JSON array of tags
});

// Platform-specific adapted versions
export const postVariants = sqliteTable('post_variants', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  postId: integer('post_id').notNull().references(() => posts.id),
  platform: text('platform').notNull(),
  adaptedText: text('adapted_text').notNull(),
  charCount: integer('char_count'),
  publishedAt: text('published_at'),
  platformPostId: text('platform_post_id'),
  platformUrl: text('platform_url'),
  status: text('status').default('pending'),        // pending, published, failed, skipped
  errorMessage: text('error_message'),
});

// Publish log
export const publishLog = sqliteTable('publish_log', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  postId: integer('post_id').references(() => posts.id),
  platform: text('platform'),
  action: text('action'),                           // 'publish', 'delete', 'error'
  details: text('details'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
});
```

---

## Authentication Setup (Better Auth)

### Installation
```bash
npm install better-auth
```

### Server config (`src/lib/server/auth.ts`):
```ts
import { betterAuth } from 'better-auth';
import { drizzleAdapter } from 'better-auth/adapters/drizzle';
import { sveltekitCookies } from 'better-auth/svelte-kit';
import { getRequestEvent } from '$app/server';
import { db } from './db';

export const auth = betterAuth({
  database: drizzleAdapter(db, { provider: 'sqlite' }),
  emailAndPassword: { enabled: true },
  plugins: [sveltekitCookies(getRequestEvent)],
});
```

### Hooks (`src/hooks.server.ts`):
```ts
import { auth } from '$lib/server/auth';
import { svelteKitHandler } from 'better-auth/svelte-kit';
import { building } from '$app/environment';

export async function handle({ event, resolve }) {
  const session = await auth.api.getSession({ headers: event.request.headers });
  if (session) {
    event.locals.session = session.session;
    event.locals.user = session.user;
  }
  return svelteKitHandler({ event, resolve, auth, building });
}
```

### Client (`src/lib/auth-client.ts`):
```ts
import { createAuthClient } from 'better-auth/svelte';
export const authClient = createAuthClient();
```

### Auth schema generation:
```bash
npx @better-auth/cli generate
```
Then merge the generated schema into `src/lib/server/db/schema.ts`.

### Protected routes:
All routes under `(app)/` group require authentication. Check `event.locals.user` in `+layout.server.ts`. Redirect unauthenticated users to `/login`.

### Auth pages:
- `/login` — email + password sign in
- `/register` — create account
- `/logout` — sign out action

---

## Application Structure

```
src/
├── routes/
│   ├── +layout.svelte              # Root layout
│   ├── login/
│   │   └── +page.svelte            # Login page
│   ├── register/
│   │   └── +page.svelte            # Registration page
│   ├── (app)/                      # Auth-protected route group
│   │   ├── +layout.svelte          # App layout with sidebar
│   │   ├── +layout.server.ts       # Auth guard — redirect if not logged in
│   │   ├── +page.svelte            # Dashboard
│   │   ├── compose/
│   │   │   └── +page.svelte        # Post composer (main feature)
│   │   ├── posts/
│   │   │   └── +page.svelte        # Post history with filters
│   │   ├── schedule/
│   │   │   └── +page.svelte        # Calendar view of scheduled posts
│   │   ├── brands/
│   │   │   └── +page.svelte        # Brand profiles management
│   │   └── settings/
│   │       └── +page.svelte        # Platform connections, AI config, appearance
├── lib/
│   ├── components/
│   │   ├── Sidebar.svelte
│   │   ├── PostComposer.svelte
│   │   ├── PlatformPreview.svelte
│   │   ├── PlatformToggle.svelte
│   │   ├── MediaUpload.svelte
│   │   ├── PostCard.svelte
│   │   ├── PublishButton.svelte
│   │   ├── BrandSwitcher.svelte
│   │   └── PlatformIcon.svelte     # Renders correct icon per platform
│   ├── server/
│   │   ├── auth.ts                 # Better Auth config
│   │   ├── db/
│   │   │   ├── index.ts            # libSQL/Drizzle connection
│   │   │   └── schema.ts           # Drizzle schema
│   │   ├── ai/
│   │   │   ├── index.ts            # Main adapt() function
│   │   │   ├── providers.ts        # Provider registry (endpoints, models, defaults)
│   │   │   └── types.ts            # Shared AI types
│   │   ├── platforms/
│   │   │   ├── index.ts            # Platform registry & publish orchestrator
│   │   │   ├── x.ts
│   │   │   ├── nostr.ts
│   │   │   ├── linkedin.ts
│   │   │   ├── bluesky.ts
│   │   │   ├── mastodon.ts
│   │   │   ├── facebook.ts
│   │   │   └── instagram.ts
│   │   └── media.ts
│   ├── auth-client.ts              # Better Auth client
│   ├── stores/
│   │   └── app.ts
│   └── utils/
│       ├── constants.ts            # Platform limits, colors, icons mapping
│       ├── formatting.ts
│       └── crypto.ts               # Encrypt/decrypt credentials
data/
├── social-manager.db
└── media/
    └── {userId}/                   # Per-user media storage
```

---

## Core Features

### 1. Authentication

- **Registration:** Email + password. After registration, redirect to onboarding (create first brand).
- **Login:** Email + password. Redirect to dashboard.
- **Session:** Persisted via cookies (Better Auth handles this). All API routes check `event.locals.user`.
- **Multi-user isolation:** Every DB query filters by `userId`. Users never see each other's data.

### 2. Brand Profiles

Each user can create multiple brand profiles. Each brand has:
- **Name** — displayed in the brand switcher
- **Description** — short context about the brand/project
- **Voice Prompt** — AI system prompt for this brand's tone and style
- **Platform connections** — which platforms are connected to this brand

Brand switcher in sidebar. Active brand affects which platforms are available in composer and which voice prompt is used for AI adaptation.

Default voice prompt template (shown when creating new brand):
```
You are a social media manager for [BRAND NAME].

[BRAND DESCRIPTION AND CONTEXT]

Brand voice:
- [Describe tone]
- [Key terminology]
- [Things to avoid]

Adapt the given text for each requested platform. Return ONLY valid JSON, no markdown fences, no preamble.

Format:
{
  "x": "...",
  "nostr": "...",
  "linkedin": "...",
  "bluesky": "...",
  "mastodon": "...",
  "facebook": "...",
  "instagram": "..."
}

Platform guidelines:
- X/TWITTER (280 chars): Punchy, concise, 1-3 hashtags
- NOSTR (~500 chars): Casual, community-oriented, minimal hashtags
- LINKEDIN (3000 chars): Professional, business-focused, CTA
- BLUESKY (300 chars): Conversational, similar to X
- MASTODON (500 chars): Community-friendly, can use CamelCase hashtags for accessibility
- FACEBOOK (long): Informative, engaging, can be longer
- INSTAGRAM (2200 chars): Visual-focused caption, relevant hashtags, emoji-friendly

Only include platforms that are requested.
```

### 3. Post Composer (Main Screen)

Layout:
- **Top bar:** Active brand indicator + brand switcher
- **Left side (55%):** Large textarea for original text. Character counter. Media upload zone (drag & drop). Tag input.
- **Right side (45%):** Scrollable preview panels for each enabled platform. Each preview shows: platform icon + name, adapted text (editable), character count with limit indicator (green/yellow/red), platform-specific warnings (e.g., "Instagram requires an image").
- **Bottom bar:** Platform toggles (only show platforms connected to active brand), "Adapt with AI" button, "Save Draft" button, "Publish All" button.

**Platform toggle logic:**
- Only show platforms that have active connections for the current brand
- Instagram toggle is disabled (greyed out with tooltip) if no media is attached
- Each toggle shows the platform icon and can be individually enabled/disabled per post

**Workflow:**
1. User writes original text
2. Selects which platforms to target (toggles)
3. Clicks "Adapt with AI" → AI provider generates platform-specific versions (or user writes them manually if AI is disabled)
4. User reviews and optionally edits each adapted version
5. Clicks "Publish All" → parallel publishing to all enabled platforms
6. Inline results: success (with link to post) or failure (with error message) per platform

### 4. AI Adaptation (Multi-Provider)

The AI layer is **optional** — the app works fully without it (manual mode). When enabled, it uses an OpenAI-compatible API interface that works with multiple providers.

#### AI Provider Architecture

All supported providers use the same OpenAI-compatible chat completions format (`/v1/chat/completions`), so the core implementation is a single function with configurable endpoint, API key, and model.

Define in `src/lib/server/ai/`:

```
src/lib/server/ai/
├── index.ts          # Main adapt() function — calls the configured provider
├── providers.ts      # Provider registry with defaults (endpoints, models)
└── types.ts          # Shared types
```

**Provider registry** (`providers.ts`):

```ts
export const AI_PROVIDERS = {
  anthropic: {
    name: 'Anthropic',
    endpoint: 'https://api.anthropic.com/v1/messages',
    defaultModel: 'claude-sonnet-4-5-20250514',
    models: ['claude-sonnet-4-5-20250514', 'claude-haiku-4-5-20251001'],
    apiKeyPrefix: 'sk-ant-',
    note: 'Uses Anthropic Messages API format (not OpenAI-compatible). Requires separate implementation path.',
  },
  openai: {
    name: 'OpenAI',
    endpoint: 'https://api.openai.com/v1/chat/completions',
    defaultModel: 'gpt-4o',
    models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4.1-nano'],
    apiKeyPrefix: 'sk-',
  },
  google: {
    name: 'Google Gemini',
    endpoint: 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions',
    defaultModel: 'gemini-2.5-flash',
    models: ['gemini-2.5-flash', 'gemini-2.5-pro'],
    note: 'Google offers a generous free tier (~1500 req/day). Great default for users who want zero cost.',
  },
  groq: {
    name: 'Groq',
    endpoint: 'https://api.groq.com/openai/v1/chat/completions',
    defaultModel: 'llama-3.3-70b-versatile',
    models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
    note: 'Very fast inference, low cost. Good for high-volume posting.',
  },
  mistral: {
    name: 'Mistral',
    endpoint: 'https://api.mistral.ai/v1/chat/completions',
    defaultModel: 'mistral-large-latest',
    models: ['mistral-large-latest', 'mistral-small-latest'],
  },
  openrouter: {
    name: 'OpenRouter',
    endpoint: 'https://openrouter.ai/api/v1/chat/completions',
    defaultModel: 'anthropic/claude-sonnet-4-5-20250514',
    models: [],  // Dynamic — OpenRouter supports 200+ models, let user type model name
    note: 'Aggregator — one API key, access to 200+ models from all providers.',
  },
  ollama: {
    name: 'Ollama (Local)',
    endpoint: 'http://localhost:11434/v1/chat/completions',
    defaultModel: 'llama3.1',
    models: [],  // Dynamic — depends on what user has pulled locally
    note: 'Runs locally, no API key needed, complete privacy. Requires Ollama installed on the machine.',
    requiresApiKey: false,
  },
  custom: {
    name: 'Custom (OpenAI-compatible)',
    endpoint: '',  // User provides
    defaultModel: '',  // User provides
    models: [],
    note: 'Any OpenAI-compatible API endpoint (LiteLLM, vLLM, LocalAI, etc.)',
  },
} as const;
```

#### API implementation

**For all providers except Anthropic**, use the OpenAI-compatible format:
```ts
const response = await fetch(endpoint, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    ...(apiKey ? { 'Authorization': `Bearer ${apiKey}` } : {}),
  },
  body: JSON.stringify({
    model,
    temperature: 0.7,
    max_tokens: 2000,
    messages: [
      { role: 'system', content: voicePrompt },
      { role: 'user', content: userPrompt },
    ],
  }),
});
const data = await response.json();
const text = data.choices[0].message.content;
```

**For Anthropic**, use the Messages API format:
```ts
const response = await fetch('https://api.anthropic.com/v1/messages', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'x-api-key': apiKey,
    'anthropic-version': '2023-06-01',
  },
  body: JSON.stringify({
    model,
    max_tokens: 2000,
    system: voicePrompt,
    messages: [{ role: 'user', content: userPrompt }],
  }),
});
const data = await response.json();
const text = data.content[0].text;
```

#### Server endpoint: `POST /api/adapt`

Request:
```json
{
  "text": "original text",
  "brandId": 1,
  "platforms": ["x", "nostr", "bluesky", "linkedin"],
  "hasMedia": true
}
```

The endpoint:
1. Verifies user owns the brand
2. Fetches brand's `voicePrompt` from DB
3. Fetches user's AI provider config from settings
4. If no AI configured → returns 400 with message "AI provider not configured"
5. Calls the configured provider's API
6. Parses JSON response (strip markdown fences if present)
7. Returns adapted versions with character counts

#### Manual mode (no AI)

If the user has no AI provider configured:
- "Adapt with AI" button is hidden or disabled (with tooltip: "Configure an AI provider in Settings")
- The original text is pre-filled into all platform preview panels
- User manually edits each platform version
- Everything else (publishing, history, etc.) works normally

### 5. Platform Publishing

Each platform module in `src/lib/server/platforms/` exports:
```ts
interface PlatformPublisher {
  publish(text: string, media?: string[], credentials: object): Promise<{
    success: boolean;
    postId?: string;
    postUrl?: string;
    error?: string;
  }>;
  testConnection(credentials: object): Promise<{
    success: boolean;
    displayName?: string;
    error?: string;
  }>;
}
```

**Platform registry** (`platforms/index.ts`) maps platform names to their modules. The `publishToAll` function takes a post with variants and publishes in parallel using `Promise.allSettled`.

**Platform-specific implementation notes:**

**X/Twitter:** Use `TwitterApi` from `twitter-api-v2`. Initialize with OAuth 1.0a tokens. Post via `client.v2.tweet()`. Media upload via `client.v1.uploadMedia()`.

**Nostr:** Use `nostr-tools`. Sign kind:1 event with nsec. Publish to user's configured relay list. Default relays: `wss://relay.damus.io`, `wss://nos.lol`, `wss://relay.nostr.band`.

**Bluesky:** Use `BskyAgent` from `@atproto/api`. Login with handle + app password. Post via `agent.post()`. Use `RichText` for proper link/mention detection.

**Mastodon:** Use `createRestAPIClient` from `masto`. Provide instance URL + access token. Post via `masto.v1.statuses.create()`.

**LinkedIn:** Direct REST API calls. `POST https://api.linkedin.com/v2/posts` with OAuth 2.0 bearer token. Handle token refresh.

**Facebook:** Meta Graph API. `POST https://graph.facebook.com/v21.0/{page-id}/feed` with Page Access Token. For photos: `/{page-id}/photos`.

**Instagram:** Meta Graph API. Two-step: create container → publish. `POST /{ig-user-id}/media` then `POST /{ig-user-id}/media_publish`. Always requires `image_url`. For carousels: create child containers first.

### 6. Settings Page

Sections:

**AI Configuration:**
- Provider selector dropdown (Anthropic, OpenAI, Google Gemini, Groq, Mistral, OpenRouter, Ollama, Custom)
- When provider is selected, show:
  - API Key input (hidden for Ollama unless user wants remote Ollama)
  - Endpoint URL (pre-filled from provider defaults, editable for Custom/Ollama)
  - Model selector (pre-filled options for known providers, free text input for OpenRouter/Ollama/Custom)
  - Temperature slider (default: 0.7)
- "Test AI Connection" button — sends a simple test prompt and shows success/failure
- "No AI / Manual mode" option — explicitly disable AI, hide "Adapt with AI" button in composer
- Show provider-specific notes (e.g., "Google Gemini offers a free tier", "Ollama runs locally — no API key needed")

**Platform Connections (per brand):**
Each platform has a card with:
- Connection status (connected/disconnected)
- "Connect" / "Disconnect" / "Test Connection" buttons
- Platform-specific credential fields:
  - **X:** API Key, API Secret, Access Token, Access Token Secret
  - **Nostr:** nsec private key or "Generate Keypair" button. Shows npub. Relay list textarea.
  - **LinkedIn:** OAuth 2.0 connect flow (redirect-based)
  - **Bluesky:** Handle (e.g., user.bsky.social) + App Password
  - **Mastodon:** Instance URL + Access Token (with link to instance settings for token generation)
  - **Facebook:** Page Access Token + Page ID (with instructions for Meta Business Suite)
  - **Instagram:** Same as Facebook (shared Meta credentials) + Instagram Business Account ID

**Account:**
- Change password
- Delete account

**Appearance:**
- Accent color picker
- Theme toggle (dark/light)

**Credential security:** All platform credentials are encrypted before storing in DB using a per-user encryption key derived from `BETTER_AUTH_SECRET`. Use Node.js `crypto` module (AES-256-GCM).

### 7. Post History

- List view with post cards: original text preview, publish status badges per platform, date, brand name
- Filter by: status, platform, brand, date range, tags
- Click to expand: full original text + all adapted versions + publish results per platform
- Actions: retry failed, re-publish, delete, duplicate as new draft
- Pagination

### 8. Dashboard

- Welcome message with user name
- Active brand display
- Stats: posts this week/month, posts per platform, success rate
- Recent activity feed (last 10 publish events)
- Quick compose shortcut button

---

## API Endpoints

All under `(app)` require authenticated session.

```
# Auth (handled by Better Auth)
POST /api/auth/*              — Better Auth handles login, register, session

# AI
POST /api/adapt               — Generate adapted versions via configured AI provider
POST /api/ai/test             — Test AI provider connection with a simple prompt

# Posts
GET  /api/posts               — List posts (filtered by user, brand, status, platform)
POST /api/posts               — Create draft
PUT  /api/posts/[id]          — Update post/draft
DELETE /api/posts/[id]        — Delete post

# Publishing
POST /api/publish             — Publish post to selected platforms
POST /api/publish/retry/[id]  — Retry failed variants

# Brands
GET  /api/brands              — List user's brands
POST /api/brands              — Create brand
PUT  /api/brands/[id]         — Update brand
DELETE /api/brands/[id]       — Delete brand
PUT  /api/brands/[id]/activate — Set active brand

# Platform connections
GET  /api/platforms            — List connections for active brand
POST /api/platforms            — Add platform connection
PUT  /api/platforms/[id]       — Update connection
DELETE /api/platforms/[id]     — Remove connection
POST /api/platforms/[id]/test  — Test connection

# Media
POST /api/media/upload         — Upload media file

# User settings
GET  /api/settings             — Get user settings
PUT  /api/settings             — Update settings
```

---

## Environment Variables (.env)

```
# Database
DATABASE_URL=file:./data/social-manager.db

# Better Auth
BETTER_AUTH_SECRET=           # openssl rand -base64 32
BETTER_AUTH_URL=http://localhost:5173

# Default AI provider (optional fallback — users configure their own in Settings)
# If set, new users get this provider pre-configured
AI_PROVIDER=                  # anthropic, openai, google, groq, mistral, openrouter, ollama, custom
AI_API_KEY=                   # API key for the default provider
AI_MODEL=                     # Model name (e.g., claude-sonnet-4-5-20250514, gpt-4o, gemini-2.5-flash)
AI_ENDPOINT=                  # Only needed for custom/ollama (e.g., http://localhost:11434/v1/chat/completions)
```

Individual AI and platform credentials are stored per-user in the DB. The .env values above are optional fallbacks for self-hosted single-user setups.

---

## Implementation Priority

1. **Project setup** — SvelteKit + Tailwind + Drizzle + libSQL + basic layout
2. **Authentication** — Better Auth setup, login/register pages, auth guard, session handling
3. **Settings page** — AI provider selector, API key input, save to DB per user
4. **Brand profiles** — CRUD, brand switcher, voice prompt editor
5. **Platform connections** — Settings UI for adding/removing platform credentials per brand
6. **Post Composer** — textarea, platform toggles, save draft, media upload zone, manual editing per platform
7. **AI Adaptation** — Multi-provider AI layer (OpenAI-compatible + Anthropic path), adapted preview panels
8. **X/Twitter publishing** — first platform end-to-end
9. **Nostr publishing** — second platform
10. **Bluesky publishing** — third platform (simple auth)
11. **Mastodon publishing** — fourth platform
12. **Post History** — list, filter, detail view, retry
13. **Facebook publishing** — Meta Graph API
14. **Instagram publishing** — Meta Graph API (image-required logic)
15. **LinkedIn publishing** — OAuth 2.0 flow
16. **Dashboard** — stats and overview
17. **Scheduling** — future datetime + cron publish
18. **Media handling improvements** — image resize, preview thumbnails

---

## Key Implementation Notes

- **Multi-user isolation:** EVERY database query must filter by `event.locals.user.id`. Never expose other users' data.
- **Credential encryption:** Platform credentials are encrypted at rest. Decrypt only when publishing.
- Use Drizzle migrations (`npx drizzle-kit push` for dev, `npx drizzle-kit migrate` for production).
- Error handling on every publish attempt — show clear inline error messages per platform.
- Character count should update live in composer and previews, with color coding (green = ok, yellow = near limit, red = over).
- AI adaptation shows loading skeletons while the provider generates.
- "Publish All" uses `Promise.allSettled` — show results as they complete, don't wait for all.
- Instagram toggle auto-disables if no media attached (with tooltip explaining why).
- Platform previews should visually differentiate — each card has the platform's brand color as accent.
- Keep all platform API logic isolated in individual modules — easy to add new platforms later.
- Nostr keypair generation should happen client-side, then nsec sent to server for encrypted storage.

---

## Nice-to-Have (Phase 2)

- Keyboard shortcut: Ctrl+Enter to publish
- Tauri wrapper for native desktop app with tray icon
- Content calendar view (monthly grid)
- Post templates (save reusable post structures)
- Thread support for X (multi-tweet threads) and Bluesky
- Analytics — basic engagement metrics per platform
- Image generation — AI-generated images for posts
- RSS/webhook trigger — auto-post when blog content is published
- Export/import brand profiles
- Team features — invite collaborators to a brand
- Telegram channel publishing
- Threads (Meta) publishing
- OAuth social login (GitHub, Google) via Better Auth plugins
- Admin panel for self-hosted instances