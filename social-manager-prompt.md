# Posthorn — Cursor Project Prompt

## Project Overview

Build a multi-user web application called **"Posthorn"** for managing and publishing social media posts across multiple platforms from a single interface. Production URL: `https://post.dvadsatjeden.org`. Source repo: `https://github.com/webiumsk/social-manager`.

The app is built with SvelteKit and can run locally or be deployed via Docker. It supports multiple users, each with their own brand profiles, platform connections, and post history. Authentication is handled by Better Auth.

---

## Tech Stack

- **Framework:** SvelteKit (latest, with TypeScript)
- **Styling:** Tailwind CSS v4 with @tailwindcss/typography plugin
- **Database:** SQLite via Drizzle ORM + `better-sqlite3` (native, synchronous, no bundling issues). WAL mode enabled for concurrent reads.
- **Authentication:** Better Auth (`better-auth` package) with email/password. Uses `better-auth/svelte-kit` integration and `sveltekitCookies` plugin.
- **AI:** Multi-provider support — OpenAI-compatible API layer supporting Anthropic, OpenAI, Google, Groq, Mistral, OpenRouter, and local Ollama. App also works fully without AI (manual mode).
- **Icons:** Lucide icons (`lucide-svelte`)
- **Media:** Local file storage in `./data/media/{userId}/`

### Platform Libraries

| Platform   | Package                  | Auth Method                        | Post Limit   |
|------------|--------------------------|-------------------------------------|-------------|
| X/Twitter  | `twitter-api-v2`         | OAuth 2.0 Quick Connect OR manual tokens | 280 chars   |
| Nostr      | `nostr-tools`            | nsec private key                   | ~unlimited  |
| LinkedIn   | REST API (fetch)         | OAuth 2.0 Quick Connect            | 3000 chars  |
| Bluesky    | `@atproto/api`           | Handle + App Password              | 300 chars   |
| Mastodon   | `masto`                  | Instance URL + Access Token        | 500 chars*  |
| Facebook   | Meta Graph API (fetch)   | OAuth Quick Connect (Facebook Login) | 63,206 chars|
| Instagram  | Meta Graph API (fetch)   | Same as Facebook (Business account)| 2200 chars  |

*Mastodon limit varies per instance, 500 is default.

**Important platform notes:**
- **Instagram** requires an image with every post (no text-only posts). The app must enforce this in the UI — disable Instagram toggle if no media is attached.
- **Facebook** posts go to a Facebook Page, not a personal profile (API limitation).
- **Bluesky** uses App Passwords (generated in Bluesky Settings), not the account password.
- **Mastodon** requires the user to specify their instance URL (e.g., mastodon.social, bitcoinhackers.org).
- **Nostr** private key must be stored securely. Offer "Generate new keypair" option.

### OAuth Quick Connect vs Manual Tokens

For platforms that support OAuth (X, LinkedIn, Facebook/Instagram), the app offers **two connection modes**:

**Quick Connect (default for regular users):**
User clicks "Connect [Platform]" → redirected to the platform's authorization page → logs in and clicks "Authorize" → redirected back to the app with tokens stored automatically. User never sees API keys or developer portals. This uses the **app owner's** developer credentials (stored server-side in .env).

**Advanced / Own API Keys (for power users):**
User manually enters their own API credentials from the platform's developer portal. Uses the user's own API quota, not the app owner's. Shown behind an "Advanced" toggle/accordion in Settings.

**Quota management for Quick Connect:**
When multiple users share the app's developer credentials via Quick Connect, all their posts count against the app's API quota. For X specifically:
- Free tier: ~500 posts/month total across all Quick Connect users
- Basic tier ($200/month): ~3,000 posts/month + 10,000 tweet reads
- Pro tier ($5,000/month): ~300,000 posts/month

The app should track Quick Connect API usage per platform and show warnings when approaching limits. When the shared quota is exhausted, prompt users to connect with their own API keys. Budget for upgrading the X API tier from subscription revenue as the userbase grows.

---

## Design Direction

- **Dark theme** as default, with option to switch to light
- **Accent color:** Configurable in settings, default purple (#7c3aed)
- **Typography:** Clean, modern sans-serif (e.g., Geist, Outfit, or similar — NOT Inter/Roboto)
- **Feel:** Developer-friendly, clean, minimal but not boring. Think "premium dev tool"
- **Cards** with subtle borders and glass-morphism effects on dark backgrounds
- **Smooth transitions** between views
- **Responsive** — works on desktop and tablet

---

## Database Schema (Drizzle ORM)

Define in `src/lib/server/db/schema.ts`:

```ts
// ============================================
// AUTH TABLES (generated by Better Auth CLI)
// ============================================
// Run: npx @better-auth/cli generate
// Then merge the generated auth schema into this file.
// Better Auth creates: user, session, account, verification tables.
// Do NOT manually define these — let Better Auth generate them.
// After generation, add any custom columns to the user table if needed.

// ============================================
// APPLICATION TABLES
// ============================================

// Brand profiles — each user can have multiple brands
export const brands = sqliteTable('brands', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),               // References Better Auth user.id
  name: text('name').notNull(),                     // e.g., "SatFlux", "My Blog"
  description: text('description'),                 // Short description of the brand
  voicePrompt: text('voice_prompt').notNull(),      // AI system prompt for brand voice
  isActive: integer('is_active').default(0),        // Currently selected brand for this user
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
});

// Platform connections — per user, per brand
export const platformConnections = sqliteTable('platform_connections', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  brandId: integer('brand_id').references(() => brands.id),
  platform: text('platform').notNull(),             // 'x', 'nostr', 'linkedin', 'bluesky', 'mastodon', 'facebook', 'instagram'
  credentials: text('credentials').notNull(),       // JSON - encrypted platform-specific credentials
  displayName: text('display_name'),                // e.g., "@satflux" or "SatFlux Page"
  isActive: integer('is_active').default(1),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
});

// Posts table
export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  brandId: integer('brand_id').references(() => brands.id),
  originalText: text('original_text').notNull(),
  status: text('status').default('draft'),          // draft, scheduled, published, partial, failed
  scheduledAt: text('scheduled_at'),
  publishedAt: text('published_at'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
  mediaPaths: text('media_paths'),                  // JSON array of file paths
  tags: text('tags'),                               // JSON array of tags
});

// Platform-specific adapted versions
export const postVariants = sqliteTable('post_variants', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  postId: integer('post_id').notNull().references(() => posts.id),
  platform: text('platform').notNull(),
  adaptedText: text('adapted_text').notNull(),
  charCount: integer('char_count'),
  publishedAt: text('published_at'),
  platformPostId: text('platform_post_id'),
  platformUrl: text('platform_url'),
  status: text('status').default('pending'),        // pending, published, failed, skipped
  errorMessage: text('error_message'),
});

// Publish log
export const publishLog = sqliteTable('publish_log', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  postId: integer('post_id').references(() => posts.id),
  platform: text('platform'),
  action: text('action'),                           // 'publish', 'delete', 'error'
  details: text('details'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
});

// ============================================
// SUBSCRIPTION & BILLING TABLES
// ============================================

// User subscriptions
export const subscriptions = sqliteTable('subscriptions', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull().unique(),
  tier: text('tier').notNull().default('free'),     // 'free', 'pro', 'team'
  status: text('status').default('active'),          // 'active', 'past_due', 'cancelled', 'expired'
  currentPeriodStart: text('current_period_start'),
  currentPeriodEnd: text('current_period_end'),
  cancelAtPeriodEnd: integer('cancel_at_period_end').default(0),
  paymentMethod: text('payment_method'),             // 'lightning', 'stripe', 'manual'
  stripeCustomerId: text('stripe_customer_id'),
  stripeSubscriptionId: text('stripe_subscription_id'),
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
  updatedAt: text('updated_at').default(sql`CURRENT_TIMESTAMP`),
});

// Payment history
export const payments = sqliteTable('payments', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  amount: integer('amount').notNull(),               // Amount in sats (Lightning) or cents (Stripe)
  currency: text('currency').notNull(),              // 'sats' or 'usd'
  tier: text('tier').notNull(),                      // What tier was paid for
  period: text('period'),                            // 'monthly' or 'yearly'
  paymentMethod: text('payment_method').notNull(),   // 'lightning', 'stripe'
  externalId: text('external_id'),                   // Lightning invoice hash or Stripe payment intent ID
  status: text('status').default('pending'),          // 'pending', 'completed', 'failed', 'refunded'
  createdAt: text('created_at').default(sql`CURRENT_TIMESTAMP`),
});

// AI usage tracking (for metered billing / fair use)
export const aiUsage = sqliteTable('ai_usage', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: text('user_id').notNull(),
  month: text('month').notNull(),                    // '2026-02' format
  adaptationsCount: integer('adaptations_count').default(0),
  tokensUsed: integer('tokens_used').default(0),
  providerCost: integer('provider_cost').default(0), // Cost in microdollars (for internal tracking)
});
```

### Database Connection (`src/lib/server/db/index.ts`)

**IMPORTANT:** Use `better-sqlite3`, NOT `@libsql/client`. libSQL has dynamic require issues that break SvelteKit adapter-node production builds in Docker.

```ts
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import { mkdirSync } from 'node:fs';
import path from 'node:path';
import * as schema from './schema';
import { env } from '$env/dynamic/private';

if (!env.DATABASE_URL) throw new Error('DATABASE_URL is not set');

const filePath = env.DATABASE_URL.replace(/^file:\/\//, '').replace(/^file:/, '').trim();
const fullPath = path.isAbsolute(filePath) ? filePath : path.join(process.cwd(), filePath);
const dir = path.dirname(fullPath);

try {
	mkdirSync(dir, { recursive: true });
} catch {
	// ignore if already exists
}

const sqlite = new Database(fullPath);
sqlite.pragma('journal_mode = WAL');
sqlite.pragma('foreign_keys = ON');

export const db = drizzle(sqlite, { schema });
```

Install: `npm install better-sqlite3 drizzle-orm && npm install -D @types/better-sqlite3`

Do NOT install `@libsql/client` — it causes `Could not dynamically require "@libsql/linux-x64-musl"` errors in production.

### Vite Config (`vite.config.ts`)

```ts
import tailwindcss from '@tailwindcss/vite';
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()]
});
```

Keep this clean — no `ssr.external` needed with `better-sqlite3`.

### SvelteKit Config (`svelte.config.js`)

```js
import adapter from '@sveltejs/adapter-node';

const config = {
	kit: {
		adapter: adapter()
	}
};

export default config;
```

Default output directory (`build/`). Do NOT change `out` — the Dockerfile and deploy.sh depend on this path.

---

## Authentication Setup (Better Auth)

### Installation
```bash
npm install better-auth
```

### Server config (`src/lib/server/auth.ts`):
```ts
import { betterAuth } from 'better-auth';
import { drizzleAdapter } from 'better-auth/adapters/drizzle';
import { sveltekitCookies } from 'better-auth/svelte-kit';
import { getRequestEvent } from '$app/server';
import { db } from './db';

export const auth = betterAuth({
  database: drizzleAdapter(db, { provider: 'sqlite' }),
  emailAndPassword: { enabled: true },
  plugins: [sveltekitCookies(getRequestEvent)],
});
```

### Hooks (`src/hooks.server.ts`):
```ts
import { auth } from '$lib/server/auth';
import { svelteKitHandler } from 'better-auth/svelte-kit';
import { building } from '$app/environment';

export async function handle({ event, resolve }) {
  const session = await auth.api.getSession({ headers: event.request.headers });
  if (session) {
    event.locals.session = session.session;
    event.locals.user = session.user;
  }
  return svelteKitHandler({ event, resolve, auth, building });
}
```

### Client (`src/lib/auth-client.ts`):
```ts
import { createAuthClient } from 'better-auth/svelte';
export const authClient = createAuthClient();
```

### Auth schema generation:
```bash
npx @better-auth/cli generate
```
Then merge the generated schema into `src/lib/server/db/schema.ts`.

### Protected routes:
All routes under `(app)/` group require authentication. Check `event.locals.user` in `+layout.server.ts`. Redirect unauthenticated users to `/login`.

### Auth pages:
- `/login` — email + password sign in
- `/register` — create account
- `/logout` — sign out action

---

## Application Structure

```
src/
├── routes/
│   ├── +layout.svelte              # Root layout
│   ├── login/
│   │   └── +page.svelte            # Login page
│   ├── register/
│   │   └── +page.svelte            # Registration page
│   ├── pricing/
│   │   └── +page.svelte            # Public pricing page (no auth required)
│   ├── (app)/                      # Auth-protected route group
│   │   ├── +layout.svelte          # App layout with sidebar
│   │   ├── +layout.server.ts       # Auth guard — redirect if not logged in
│   │   ├── +page.svelte            # Dashboard
│   │   ├── compose/
│   │   │   └── +page.svelte        # Post composer (main feature)
│   │   ├── posts/
│   │   │   └── +page.svelte        # Post history with filters
│   │   ├── schedule/
│   │   │   └── +page.svelte        # Calendar view of scheduled posts
│   │   ├── brands/
│   │   │   └── +page.svelte        # Brand profiles management
│   │   ├── billing/
│   │   │   └── +page.svelte        # Subscription management, usage, payment history
│   │   └── settings/
│   │       └── +page.svelte        # Platform connections, AI config, appearance
├── lib/
│   ├── components/
│   │   ├── Sidebar.svelte
│   │   ├── PostComposer.svelte
│   │   ├── PlatformPreview.svelte
│   │   ├── PlatformToggle.svelte
│   │   ├── MediaUpload.svelte
│   │   ├── PostCard.svelte
│   │   ├── PublishButton.svelte
│   │   ├── BrandSwitcher.svelte
│   │   └── PlatformIcon.svelte     # Renders correct icon per platform
│   ├── server/
│   │   ├── auth.ts                 # Better Auth config
│   │   ├── db/
│   │   │   ├── index.ts            # better-sqlite3/Drizzle connection
│   │   │   └── schema.ts           # Drizzle schema
│   │   ├── ai/
│   │   │   ├── index.ts            # Main adapt() function
│   │   │   ├── providers.ts        # Provider registry (endpoints, models, defaults)
│   │   │   └── types.ts            # Shared AI types
│   │   ├── platforms/
│   │   │   ├── index.ts            # Platform registry & publish orchestrator
│   │   │   ├── x.ts
│   │   │   ├── nostr.ts
│   │   │   ├── linkedin.ts
│   │   │   ├── bluesky.ts
│   │   │   ├── mastodon.ts
│   │   │   ├── facebook.ts
│   │   │   └── instagram.ts
│   │   ├── billing/
│   │   │   ├── tiers.ts            # Tier definitions, limits, pricing
│   │   │   ├── guard.ts            # Tier enforcement (checkTierLimit)
│   │   │   ├── subscription.ts     # Subscription CRUD logic
│   │   │   ├── lightning.ts        # SatFlux Lightning invoice creation/verification
│   │   │   ├── stripe.ts           # Stripe Checkout & webhook handling
│   │   │   └── usage.ts            # AI & post usage tracking/queries
│   │   └── media.ts
│   ├── auth-client.ts              # Better Auth client
│   ├── stores/
│   │   └── app.ts
│   └── utils/
│       ├── constants.ts            # Platform limits, colors, icons mapping
│       ├── formatting.ts
│       └── crypto.ts               # Encrypt/decrypt credentials
data/
├── social-manager.db
└── media/
    └── {userId}/                   # Per-user media storage
```

---

## Core Features

### 1. Authentication

- **Registration:** Email + password. After registration, redirect to onboarding (create first brand).
- **Login:** Email + password. Redirect to dashboard.
- **Session:** Persisted via cookies (Better Auth handles this). All API routes check `event.locals.user`.
- **Multi-user isolation:** Every DB query filters by `userId`. Users never see each other's data.

### 2. Brand Profiles

Each user can create multiple brand profiles. Each brand has:
- **Name** — displayed in the brand switcher
- **Description** — short context about the brand/project
- **Voice Prompt** — AI system prompt for this brand's tone and style
- **Platform connections** — which platforms are connected to this brand

Brand switcher in sidebar. Active brand affects which platforms are available in composer and which voice prompt is used for AI adaptation.

Default voice prompt template (shown when creating new brand):
```
You are a social media manager for [BRAND NAME].

[BRAND DESCRIPTION AND CONTEXT]

Brand voice:
- [Describe tone]
- [Key terminology]
- [Things to avoid]

Adapt the given text for each requested platform. Return ONLY valid JSON, no markdown fences, no preamble.

Format:
{
  "x": "...",
  "nostr": "...",
  "linkedin": "...",
  "bluesky": "...",
  "mastodon": "...",
  "facebook": "...",
  "instagram": "..."
}

Platform guidelines:
- X/TWITTER (280 chars): Punchy, concise, 1-3 hashtags
- NOSTR (~500 chars): Casual, community-oriented, minimal hashtags
- LINKEDIN (3000 chars): Professional, business-focused, CTA
- BLUESKY (300 chars): Conversational, similar to X
- MASTODON (500 chars): Community-friendly, can use CamelCase hashtags for accessibility
- FACEBOOK (long): Informative, engaging, can be longer
- INSTAGRAM (2200 chars): Visual-focused caption, relevant hashtags, emoji-friendly

Only include platforms that are requested.
```

### 3. Post Composer (Main Screen)

Layout:
- **Top bar:** Active brand indicator + brand switcher
- **Left side (55%):** Large textarea for original text. Character counter. Media upload zone (drag & drop). Tag input.
- **Right side (45%):** Scrollable preview panels for each enabled platform. Each preview shows: platform icon + name, adapted text (editable), character count with limit indicator (green/yellow/red), platform-specific warnings (e.g., "Instagram requires an image").
- **Bottom bar:** Platform toggles (only show platforms connected to active brand), "Adapt with AI" button, "Save Draft" button, "Publish All" button.

**Platform toggle logic:**
- Only show platforms that have active connections for the current brand
- Instagram toggle is disabled (greyed out with tooltip) if no media is attached
- Each toggle shows the platform icon and can be individually enabled/disabled per post

**Workflow:**
1. User writes original text
2. Selects which platforms to target (toggles)
3. Clicks "Adapt with AI" → AI provider generates platform-specific versions (or user writes them manually if AI is disabled)
4. User reviews and optionally edits each adapted version
5. Clicks "Publish All" → parallel publishing to all enabled platforms
6. Inline results: success (with link to post) or failure (with error message) per platform

### 4. AI Adaptation (Multi-Provider)

The AI layer is **optional** — the app works fully without it (manual mode). When enabled, it uses an OpenAI-compatible API interface that works with multiple providers.

#### AI Provider Architecture

All supported providers use the same OpenAI-compatible chat completions format (`/v1/chat/completions`), so the core implementation is a single function with configurable endpoint, API key, and model.

Define in `src/lib/server/ai/`:

```
src/lib/server/ai/
├── index.ts          # Main adapt() function — calls the configured provider
├── providers.ts      # Provider registry with defaults (endpoints, models)
└── types.ts          # Shared types
```

**Provider registry** (`providers.ts`):

```ts
export const AI_PROVIDERS = {
  anthropic: {
    name: 'Anthropic',
    endpoint: 'https://api.anthropic.com/v1/messages',
    defaultModel: 'claude-sonnet-4-5-20250514',
    models: ['claude-sonnet-4-5-20250514', 'claude-haiku-4-5-20251001'],
    apiKeyPrefix: 'sk-ant-',
    note: 'Uses Anthropic Messages API format (not OpenAI-compatible). Requires separate implementation path.',
  },
  openai: {
    name: 'OpenAI',
    endpoint: 'https://api.openai.com/v1/chat/completions',
    defaultModel: 'gpt-4o',
    models: ['gpt-4o', 'gpt-4o-mini', 'gpt-4.1-nano'],
    apiKeyPrefix: 'sk-',
  },
  google: {
    name: 'Google Gemini',
    endpoint: 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions',
    defaultModel: 'gemini-2.5-flash',
    models: ['gemini-2.5-flash', 'gemini-2.5-pro'],
    note: 'Google offers a generous free tier (~1500 req/day). Great default for users who want zero cost.',
  },
  groq: {
    name: 'Groq',
    endpoint: 'https://api.groq.com/openai/v1/chat/completions',
    defaultModel: 'llama-3.3-70b-versatile',
    models: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'],
    note: 'Very fast inference, low cost. Good for high-volume posting.',
  },
  mistral: {
    name: 'Mistral',
    endpoint: 'https://api.mistral.ai/v1/chat/completions',
    defaultModel: 'mistral-large-latest',
    models: ['mistral-large-latest', 'mistral-small-latest'],
  },
  openrouter: {
    name: 'OpenRouter',
    endpoint: 'https://openrouter.ai/api/v1/chat/completions',
    defaultModel: 'anthropic/claude-sonnet-4-5-20250514',
    models: [],  // Dynamic — OpenRouter supports 200+ models, let user type model name
    note: 'Aggregator — one API key, access to 200+ models from all providers.',
  },
  ollama: {
    name: 'Ollama (Local)',
    endpoint: 'http://localhost:11434/v1/chat/completions',
    defaultModel: 'llama3.1',
    models: [],  // Dynamic — depends on what user has pulled locally
    note: 'Runs locally, no API key needed, complete privacy. Requires Ollama installed on the machine.',
    requiresApiKey: false,
  },
  custom: {
    name: 'Custom (OpenAI-compatible)',
    endpoint: '',  // User provides
    defaultModel: '',  // User provides
    models: [],
    note: 'Any OpenAI-compatible API endpoint (LiteLLM, vLLM, LocalAI, etc.)',
  },
} as const;
```

#### API implementation

**For all providers except Anthropic**, use the OpenAI-compatible format:
```ts
const response = await fetch(endpoint, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    ...(apiKey ? { 'Authorization': `Bearer ${apiKey}` } : {}),
  },
  body: JSON.stringify({
    model,
    temperature: 0.7,
    max_tokens: 2000,
    messages: [
      { role: 'system', content: voicePrompt },
      { role: 'user', content: userPrompt },
    ],
  }),
});
const data = await response.json();
const text = data.choices[0].message.content;
```

**For Anthropic**, use the Messages API format:
```ts
const response = await fetch('https://api.anthropic.com/v1/messages', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'x-api-key': apiKey,
    'anthropic-version': '2023-06-01',
  },
  body: JSON.stringify({
    model,
    max_tokens: 2000,
    system: voicePrompt,
    messages: [{ role: 'user', content: userPrompt }],
  }),
});
const data = await response.json();
const text = data.content[0].text;
```

#### Server endpoint: `POST /api/adapt`

Request:
```json
{
  "text": "original text",
  "brandId": 1,
  "platforms": ["x", "nostr", "bluesky", "linkedin"],
  "hasMedia": true
}
```

The endpoint:
1. Verifies user owns the brand
2. Fetches brand's `voicePrompt` from DB
3. Fetches user's AI provider config from settings
4. If no AI configured → returns 400 with message "AI provider not configured"
5. Calls the configured provider's API
6. Parses JSON response (strip markdown fences if present)
7. Returns adapted versions with character counts

#### Manual mode (no AI)

If the user has no AI provider configured:
- "Adapt with AI" button is hidden or disabled (with tooltip: "Configure an AI provider in Settings")
- The original text is pre-filled into all platform preview panels
- User manually edits each platform version
- Everything else (publishing, history, etc.) works normally

### 5. Platform Publishing

Each platform module in `src/lib/server/platforms/` exports:
```ts
interface PlatformPublisher {
  publish(text: string, media?: string[], credentials: object): Promise<{
    success: boolean;
    postId?: string;
    postUrl?: string;
    error?: string;
  }>;
  testConnection(credentials: object): Promise<{
    success: boolean;
    displayName?: string;
    error?: string;
  }>;
}
```

**Platform registry** (`platforms/index.ts`) maps platform names to their modules. The `publishToAll` function takes a post with variants and publishes in parallel using `Promise.allSettled`.

**Platform-specific implementation notes:**

**X/Twitter:** Use `TwitterApi` from `twitter-api-v2`. Supports two auth modes:
- **Quick Connect users:** Initialize with OAuth 2.0 user access token (obtained from OAuth flow, stored in DB). Post via `client.v2.tweet()`. Tokens refresh automatically via refresh_token — store both access_token and refresh_token, refresh when expired.
- **Own API Keys users:** Initialize with OAuth 1.0a (4 manual tokens). Post via `client.v2.tweet()`. Media upload via `client.v1.uploadMedia()`.
- The platform module should detect which auth mode the user's connection uses and initialize the client accordingly.

**Nostr:** Use `nostr-tools`. Sign kind:1 event with nsec. Publish to user's configured relay list. Default relays: `wss://relay.damus.io`, `wss://nos.lol`, `wss://relay.nostr.band`.

**Bluesky:** Use `BskyAgent` from `@atproto/api`. Login with handle + app password. Post via `agent.post()`. Use `RichText` for proper link/mention detection.

**Mastodon:** Use `createRestAPIClient` from `masto`. Provide instance URL + access token. Post via `masto.v1.statuses.create()`.

**LinkedIn:** Direct REST API calls. `POST https://api.linkedin.com/v2/posts` with OAuth 2.0 bearer token. Handle token refresh.

**Facebook:** Meta Graph API. `POST https://graph.facebook.com/v21.0/{page-id}/feed` with Page Access Token. For photos: `/{page-id}/photos`.

**Instagram:** Meta Graph API. Two-step: create container → publish. `POST /{ig-user-id}/media` then `POST /{ig-user-id}/media_publish`. Always requires `image_url`. For carousels: create child containers first.

### 6. Settings Page

Sections:

**AI Configuration:**
- Provider selector dropdown (Anthropic, OpenAI, Google Gemini, Groq, Mistral, OpenRouter, Ollama, Custom)
- When provider is selected, show:
  - API Key input (hidden for Ollama unless user wants remote Ollama)
  - Endpoint URL (pre-filled from provider defaults, editable for Custom/Ollama)
  - Model selector (pre-filled options for known providers, free text input for OpenRouter/Ollama/Custom)
  - Temperature slider (default: 0.7)
- "Test AI Connection" button — sends a simple test prompt and shows success/failure
- "No AI / Manual mode" option — explicitly disable AI, hide "Adapt with AI" button in composer
- Show provider-specific notes (e.g., "Google Gemini offers a free tier", "Ollama runs locally — no API key needed")

**Platform Connections (per brand):**
Each platform has a card with:
- Connection status indicator (connected/disconnected/error)
- Connected account display name (e.g., "@satflux")
- "Connect" / "Disconnect" / "Test Connection" buttons

Platform-specific connection UI:

- **X/Twitter:**
  - **Default tab — "Quick Connect":** Single button "Connect X Account" → OAuth 2.0 PKCE flow → user authorizes on X → tokens stored automatically. User sees only their connected account name. Uses app's shared X API quota.
  - **Advanced tab — "Use Own API Keys":** Collapsible section with 4 fields: API Key, API Secret, Access Token, Access Token Secret. Link to developer.x.com with short instructions. Uses user's own API quota.
  - Show which mode is active and a badge: "Shared quota" or "Own quota"

- **LinkedIn:**
  - "Connect LinkedIn" button → OAuth 2.0 redirect flow → user authorizes → tokens stored. Fully OAuth, no manual keys needed.

- **Facebook:**
  - "Connect Facebook Page" button → Facebook Login OAuth flow → user selects which Page to connect → Page Access Token stored. Show connected Page name.

- **Instagram:**
  - Appears after Facebook is connected (shares Meta credentials). User selects which Instagram Business account to link. Show connected account name.

- **Nostr:**
  - nsec private key input OR "Generate New Keypair" button. Shows derived npub (read-only). Relay list textarea (one URL per line, pre-filled with defaults).

- **Bluesky:**
  - Handle input (e.g., `user.bsky.social`) + App Password input. Link to Bluesky Settings with instructions for generating an App Password.

- **Mastodon:**
  - Instance URL input (e.g., `https://mastodon.social`) + Access Token input. "How to get a token" expandable instructions linking to the user's instance settings (`/settings/applications`).

**Account:**
- Change password
- Delete account

**Appearance:**
- Accent color picker
- Theme toggle (dark/light)

**Credential security:** All platform credentials (both Quick Connect tokens and manual keys) are encrypted before storing in DB using a per-user encryption key derived from `BETTER_AUTH_SECRET`. Use Node.js `crypto` module (AES-256-GCM).

### 7. Post History

- List view with post cards: original text preview, publish status badges per platform, date, brand name
- Filter by: status, platform, brand, date range, tags
- Click to expand: full original text + all adapted versions + publish results per platform
- Actions: retry failed, re-publish, delete, duplicate as new draft
- Pagination

### 8. Dashboard

- Welcome message with user name
- Active brand display
- Current subscription tier badge + usage stats
- Stats: posts this week/month, posts per platform, success rate
- Recent activity feed (last 10 publish events)
- Quick compose shortcut button
- Upgrade prompt for free users (non-intrusive, shown once per session)

### 9. Subscription & Pricing

#### Tier Definitions

Define in `src/lib/server/billing/tiers.ts`:

```ts
export const TIERS = {
  free: {
    name: 'Free',
    price: { monthly: 0, yearly: 0 },
    limits: {
      brands: 1,
      platforms: 3,              // Max connected platforms per brand
      postsPerMonth: 30,
      aiAdaptationsPerMonth: 0,  // No AI on free tier — manual mode only
      mediaStorageMb: 50,
    },
    features: {
      scheduling: false,
      analytics: false,
      customBranding: false,
      prioritySupport: false,
    },
  },
  pro: {
    name: 'Pro',
    price: {
      monthly: { usd: 900, sats: 15000 },   // $9/month or 15,000 sats
      yearly: { usd: 7900, sats: 130000 },   // $79/year or 130,000 sats (save ~27%)
    },
    limits: {
      brands: 5,
      platforms: 7,              // All platforms
      postsPerMonth: -1,         // Unlimited
      aiAdaptationsPerMonth: 500,
      mediaStorageMb: 1000,
    },
    features: {
      scheduling: true,
      analytics: true,
      customBranding: true,
      prioritySupport: false,
    },
  },
  team: {
    name: 'Team',
    price: {
      monthly: { usd: 2500, sats: 42000 },
      yearly: { usd: 22000, sats: 370000 },
    },
    limits: {
      brands: -1,               // Unlimited
      platforms: 7,
      postsPerMonth: -1,
      aiAdaptationsPerMonth: -1, // Unlimited
      mediaStorageMb: 5000,
    },
    features: {
      scheduling: true,
      analytics: true,
      customBranding: true,
      prioritySupport: true,
      teamMembers: 5,           // Up to 5 users per team
      approvalWorkflow: true,
    },
  },
} as const;
```

**Important:** Sat prices should be configurable — update periodically based on BTC/USD rate or fetch dynamically. Store base prices in USD, convert to sats at payment time using a rate API.

#### Tier Enforcement Middleware

Create `src/lib/server/billing/guard.ts`:

```ts
// Middleware/helper to check tier limits before actions
export async function checkTierLimit(userId: string, action: 'post' | 'adapt' | 'brand' | 'platform') {
  const subscription = await getUserSubscription(userId);
  const tier = TIERS[subscription.tier];
  const usage = await getCurrentUsage(userId);

  switch (action) {
    case 'post':
      if (tier.limits.postsPerMonth !== -1 && usage.postsThisMonth >= tier.limits.postsPerMonth)
        return { allowed: false, reason: `Post limit reached (${tier.limits.postsPerMonth}/month). Upgrade to Pro for unlimited posts.` };
      break;
    case 'adapt':
      if (tier.limits.aiAdaptationsPerMonth === 0)
        return { allowed: false, reason: 'AI adaptation requires a Pro subscription. You can still edit posts manually.' };
      if (tier.limits.aiAdaptationsPerMonth !== -1 && usage.adaptationsThisMonth >= tier.limits.aiAdaptationsPerMonth)
        return { allowed: false, reason: `AI adaptation limit reached (${tier.limits.aiAdaptationsPerMonth}/month).` };
      break;
    case 'brand':
      if (tier.limits.brands !== -1 && usage.brandsCount >= tier.limits.brands)
        return { allowed: false, reason: `Brand limit reached (${tier.limits.brands}). Upgrade to add more brands.` };
      break;
    case 'platform':
      if (usage.platformsCount >= tier.limits.platforms)
        return { allowed: false, reason: `Platform limit reached (${tier.limits.platforms}). Upgrade for all platforms.` };
      break;
  }
  return { allowed: true };
}
```

Call `checkTierLimit()` in every relevant API endpoint before performing the action. Return 403 with the reason message if not allowed. The frontend should show a friendly upgrade prompt modal when it receives a 403 from tier limits.

#### Payment Processing

**Dual payment system — Lightning (primary) + Stripe (fallback):**

**Lightning payments via SatFlux API:**
The app itself uses SatFlux for Lightning payments — dogfooding the product. When a user clicks "Pay with Lightning":
1. Server calls SatFlux API to create a Lightning invoice for the sat amount
2. User sees a QR code with the BOLT11 invoice + click-to-copy
3. Server polls or uses webhook to detect payment
4. On confirmation, activate/extend subscription in DB

**Stripe payments (fiat fallback):**
For users who prefer or need to pay in fiat. Use `stripe` npm package with SvelteKit webhook handler.
1. User clicks "Pay with Card" → redirect to Stripe Checkout
2. Stripe handles payment UI
3. Stripe webhook (`customer.subscription.created`, `invoice.paid`) updates subscription in DB

**Payment infrastructure files:**
```
src/lib/server/billing/
├── tiers.ts            # Tier definitions and limits
├── guard.ts            # Tier enforcement middleware
├── lightning.ts        # SatFlux/Lightning invoice creation & verification
├── stripe.ts           # Stripe checkout session & webhook handling
├── subscription.ts     # Subscription CRUD (create, upgrade, downgrade, cancel)
└── usage.ts            # Track and query usage counters
```

#### Pricing Page

Public page (no auth required): `/pricing`

- Three-column layout showing Free / Pro / Team tiers
- Feature comparison matrix
- Toggle between monthly/yearly pricing
- Toggle between sats/USD display
- "Get Started" for free, "Subscribe" for paid tiers
- If user is logged in, show current tier highlighted and "Upgrade"/"Downgrade" buttons
- Lightning payment shows QR code in modal
- Stripe payment redirects to Stripe Checkout

#### Subscription Management

In Settings page, add **Subscription** section:
- Current tier and status
- Next billing date
- Usage stats (posts this month, AI adaptations used, storage used) with progress bars
- "Upgrade" / "Downgrade" / "Cancel" buttons
- Payment history table (date, amount, method, receipt)
- If cancelled, show "Reactivate" option

#### Self-Hosted Mode

When the app is self-hosted (detected by `SELF_HOSTED=true` in .env), disable the entire billing system:
- All users get Team-tier features
- Pricing page shows "This is a self-hosted instance. All features are available."
- No payment endpoints activated
- AI usage still tracked for the admin's reference but not limited

This lets the open-source community run the full app without any artificial restrictions.

---

## API Endpoints

All under `(app)` require authenticated session.

```
# Auth (handled by Better Auth)
POST /api/auth/*              — Better Auth handles login, register, session

# AI
POST /api/adapt               — Generate adapted versions via configured AI provider
POST /api/ai/test             — Test AI provider connection with a simple prompt

# Posts
GET  /api/posts               — List posts (filtered by user, brand, status, platform)
POST /api/posts               — Create draft
PUT  /api/posts/[id]          — Update post/draft
DELETE /api/posts/[id]        — Delete post

# Publishing
POST /api/publish             — Publish post to selected platforms
POST /api/publish/retry/[id]  — Retry failed variants

# Brands
GET  /api/brands              — List user's brands
POST /api/brands              — Create brand (checks tier limit)
PUT  /api/brands/[id]         — Update brand
DELETE /api/brands/[id]       — Delete brand
PUT  /api/brands/[id]/activate — Set active brand

# Platform connections
GET  /api/platforms            — List connections for active brand
POST /api/platforms            — Add platform connection manually (checks tier limit)
PUT  /api/platforms/[id]       — Update connection
DELETE /api/platforms/[id]     — Remove connection
POST /api/platforms/[id]/test  — Test connection

# OAuth Quick Connect flows
GET  /api/oauth/x/authorize        — Start X OAuth 2.0 PKCE flow (redirect to X)
GET  /api/oauth/x/callback         — X OAuth callback (exchange code for tokens, store, redirect to settings)
GET  /api/oauth/linkedin/authorize  — Start LinkedIn OAuth flow
GET  /api/oauth/linkedin/callback   — LinkedIn OAuth callback
GET  /api/oauth/facebook/authorize  — Start Facebook Login OAuth flow
GET  /api/oauth/facebook/callback   — Facebook OAuth callback (handles both FB Pages and Instagram)
POST /api/oauth/[platform]/refresh  — Refresh expired OAuth tokens

# Media
POST /api/media/upload         — Upload media file (checks storage limit)

# User settings
GET  /api/settings             — Get user settings
PUT  /api/settings             — Update settings

# Billing & Subscriptions
GET  /api/billing/subscription     — Get current subscription + usage stats
POST /api/billing/checkout/lightning — Create Lightning invoice (returns BOLT11)
POST /api/billing/checkout/stripe   — Create Stripe Checkout session (returns URL)
POST /api/billing/webhook/lightning — SatFlux payment confirmation webhook
POST /api/billing/webhook/stripe    — Stripe webhook (signature verified)
PUT  /api/billing/subscription      — Change tier (upgrade/downgrade)
DELETE /api/billing/subscription    — Cancel subscription
GET  /api/billing/payments         — Payment history
GET  /api/billing/usage            — Current month usage breakdown
```

---

## Environment & Configuration Files

### `.env` (local development — Git-ignored)

```
# Database
DATABASE_URL=file:./data/social-manager.db

# Better Auth
BETTER_AUTH_SECRET=           # openssl rand -base64 32
BETTER_AUTH_URL=http://localhost:5173

# Default AI provider (optional — users configure their own in Settings)
AI_PROVIDER=                  # anthropic, openai, google, groq, mistral, openrouter, ollama, custom
AI_API_KEY=
AI_MODEL=                     # e.g., claude-sonnet-4-5-20250514, gpt-4o, gemini-2.5-flash
AI_ENDPOINT=                  # Only for custom/ollama (e.g., http://localhost:11434/v1/chat/completions)

# Billing — Lightning (SatFlux)
SATFLUX_API_URL=https://api.satflux.io
SATFLUX_API_KEY=
SATFLUX_WEBHOOK_SECRET=

# Billing — Stripe (fiat fallback)
STRIPE_SECRET_KEY=sk_...
STRIPE_PUBLISHABLE_KEY=pk_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRICE_PRO_MONTHLY=
STRIPE_PRICE_PRO_YEARLY=
STRIPE_PRICE_TEAM_MONTHLY=
STRIPE_PRICE_TEAM_YEARLY=

# Self-hosted mode — 'true' disables billing and unlocks all features
SELF_HOSTED=true

# OAuth App Credentials (for Quick Connect — shared across all users)
X_CLIENT_ID=
X_CLIENT_SECRET=
LINKEDIN_CLIENT_ID=
LINKEDIN_CLIENT_SECRET=
FACEBOOK_APP_ID=
FACEBOOK_APP_SECRET=
```

### `.env.production` (production — Git-ignored, lives on server at `/opt/posthorn/`)

```
DATABASE_URL=file:/app/data/social-manager.db
BETTER_AUTH_SECRET=           # openssl rand -base64 32
BETTER_AUTH_URL=https://post.dvadsatjeden.org
SELF_HOSTED=true
```

Individual AI and platform credentials are stored per-user in the DB. The .env values are optional fallbacks for self-hosted single-user setups.

### `.gitignore` must include:

```
.env
.env.production
data/
node_modules/
build/
.svelte-kit/
```

---

## Local Development

### Prerequisites

- Node.js 22+ (`node -v`)
- npm

### Setup

```bash
git clone https://github.com/webiumsk/social-manager.git
cd social-manager
npm install
cp .env.example .env        # Then fill in BETTER_AUTH_SECRET
npx drizzle-kit push        # Create/migrate SQLite DB
npm run dev                  # → http://localhost:5173
```

### docker-compose.dev.yml (optional — for testing Docker builds locally)

```yaml
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET}
    container_name: posthorn_dev
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - PORT=3000
      - HOST=0.0.0.0
    ports:
      - "3000:3000"
    volumes:
      - ./data:/app/data
    restart: unless-stopped
```

Run with: `docker compose -f docker-compose.dev.yml up --build`

This lets you verify the Docker build works before pushing to production.

---

## Production Deployment (Docker + Traefik)

Production runs on Hetzner server alongside other Docker services (SatFlux, Passbolt, Nostr relay). Traefik handles reverse proxy and SSL.

**Domain:** `post.dvadsatjeden.org`
**Repo:** `https://github.com/webiumsk/social-manager`
**Deploy dir:** `/opt/posthorn/`

### Dockerfile (in project root, committed to Git)

```dockerfile
# Stage 1: Build
FROM node:22-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
ARG BETTER_AUTH_SECRET
ENV BETTER_AUTH_SECRET=${BETTER_AUTH_SECRET}
RUN npm run build

# Stage 2: Run
FROM node:22-alpine
WORKDIR /app
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
COPY --from=builder /app/build ./build
COPY --from=builder /app/package*.json ./
RUN npm ci --production
RUN mkdir -p /app/data /app/data/media && chown -R appuser:appgroup /app
USER appuser
ENV NODE_ENV=production PORT=3000 HOST=0.0.0.0
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=5s --retries=3 --start-period=10s \
  CMD wget --quiet --tries=1 --spider http://localhost:3000/ || exit 1
CMD ["node", "build/index.js"]
```

**CRITICAL:** Stage 2 runs `npm ci --production` instead of copying `node_modules` from builder. This ensures `better-sqlite3` native bindings are compiled correctly for the Alpine runtime. Do NOT use `npm prune` + copy approach — it breaks native modules.

### .dockerignore (in project root, committed to Git)

```
node_modules
build
.svelte-kit
data
.env
.env.production
.git
.gitignore
README.md
```

### docker-compose.yml (in project root, committed to Git — production only)

```yaml
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET}
    container_name: posthorn_prod
    env_file:
      - .env.production
    environment:
      - NODE_ENV=production
      - PORT=3000
      - HOST=0.0.0.0
    volumes:
      - app_data:/app/data
    networks:
      - passbolt_default
      - posthorn
    restart: unless-stopped
    labels:
      # HTTPS
      - "traefik.enable=true"
      - "traefik.http.routers.posthorn-https.entrypoints=websecure"
      - "traefik.http.routers.posthorn-https.rule=Host(`post.dvadsatjeden.org`)"
      - "traefik.http.routers.posthorn-https.tls=true"
      - "traefik.http.routers.posthorn-https.tls.certresolver=letsencrypt"
      # HTTP → HTTPS redirect
      - "traefik.http.routers.posthorn-http.entrypoints=web"
      - "traefik.http.routers.posthorn-http.rule=Host(`post.dvadsatjeden.org`)"
      - "traefik.http.routers.posthorn-http.middlewares=posthorn-redirect"
      - "traefik.http.middlewares.posthorn-redirect.redirectscheme.scheme=https"
      - "traefik.http.middlewares.posthorn-redirect.redirectscheme.permanent=true"
      # Service
      - "traefik.http.services.posthorn.loadbalancer.server.port=3000"

volumes:
  app_data:
    name: posthorn_data

networks:
  passbolt_default:
    external: true
  posthorn:
    name: posthorn_prod
```

### deploy.sh (in project root, committed to Git)

```bash
#!/usr/bin/env bash
set -euo pipefail

# ─── Config ──────────────────────────────────────────
REPO="https://github.com/webiumsk/social-manager.git"
DEPLOY_DIR="/opt/posthorn"
BRANCH="main"
APP_NAME="posthorn_prod"

# ─── Colors ──────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log()   { echo -e "${GREEN}[DEPLOY]${NC} $1"; }
warn()  { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; exit 1; }

# ─── Pre-checks ─────────────────────────────────────
cd "$DEPLOY_DIR" || error "Deploy directory $DEPLOY_DIR not found"
[ -f ".env.production" ] || error ".env.production not found"
command -v docker >/dev/null 2>&1 || error "Docker not installed"
command -v docker compose >/dev/null 2>&1 || error "Docker Compose not installed"

# ─── Pull latest code ───────────────────────────────
if [ -d ".git" ]; then
    log "Pulling latest from $BRANCH..."
    git fetch origin
    git reset --hard "origin/$BRANCH"
    git clean -fd
else
    log "Cloning repository..."
    cd /tmp
    git clone --branch "$BRANCH" "$REPO" posthorn_clone
    cp -r posthorn_clone/* posthorn_clone/.* "$DEPLOY_DIR/" 2>/dev/null || true
    rm -rf posthorn_clone
    cd "$DEPLOY_DIR"
fi

# ─── Load BETTER_AUTH_SECRET for build arg ───────────
export $(grep -v '^#' .env.production | grep BETTER_AUTH_SECRET | xargs)
[ -n "${BETTER_AUTH_SECRET:-}" ] || error "BETTER_AUTH_SECRET not set in .env.production"

# ─── Build & Deploy ─────────────────────────────────
log "Building Docker image..."
docker compose build --no-cache

log "Stopping old container..."
docker compose down --remove-orphans 2>/dev/null || true

log "Starting new container..."
docker compose up -d

# ─── Healthcheck ─────────────────────────────────────
log "Waiting for healthcheck..."
sleep 5

for i in $(seq 1 12); do
    STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$APP_NAME" 2>/dev/null || echo "unknown")
    if [ "$STATUS" = "healthy" ]; then
        log "Container is healthy!"
        break
    fi
    if [ "$i" -eq 12 ]; then
        warn "Healthcheck timeout — check logs: docker logs $APP_NAME"
    fi
    sleep 5
done

# ─── Cleanup ─────────────────────────────────────────
log "Cleaning up old Docker images..."
docker image prune -f >/dev/null 2>&1

# ─── Status ──────────────────────────────────────────
echo ""
log "═══════════════════════════════════════"
log "  Posthorn deployed successfully!"
log "  URL: https://post.dvadsatjeden.org"
log "  Logs: docker logs -f $APP_NAME"
log "═══════════════════════════════════════"
```

### First-time server setup

```bash
# 1. Create deploy directory
mkdir -p /opt/posthorn
cd /opt/posthorn

# 2. Clone repo
git clone https://github.com/webiumsk/social-manager.git .

# 3. Create .env.production (this file is NOT in Git)
cat > .env.production << EOF
DATABASE_URL=file:/app/data/social-manager.db
BETTER_AUTH_SECRET=$(openssl rand -base64 32)
BETTER_AUTH_URL=https://post.dvadsatjeden.org
SELF_HOSTED=true
EOF

# 4. Make deploy script executable
chmod +x deploy.sh

# 5. DNS: A record for post.dvadsatjeden.org → server IP

# 6. Deploy
./deploy.sh
```

### Subsequent deploys

After pushing changes to GitHub:
```bash
cd /opt/posthorn && ./deploy.sh
```

---

## Implementation Priority

1. **Project setup** — SvelteKit + Tailwind + Drizzle + better-sqlite3 + basic layout
2. **Authentication** — Better Auth setup, login/register pages, auth guard, session handling
3. **Settings page** — AI provider selector, API key input, save to DB per user
4. **Brand profiles** — CRUD, brand switcher, voice prompt editor
5. **Platform connections** — Settings UI for adding/removing platform credentials per brand
6. **Post Composer** — textarea, platform toggles, save draft, media upload zone, manual editing per platform
7. **AI Adaptation** — Multi-provider AI layer (OpenAI-compatible + Anthropic path), adapted preview panels
8. **X/Twitter publishing** — first platform end-to-end
9. **Nostr publishing** — second platform
10. **Bluesky publishing** — third platform (simple auth)
11. **Mastodon publishing** — fourth platform
12. **Post History** — list, filter, detail view, retry
13. **Subscription tiers & enforcement** — tier definitions, guard middleware, usage tracking, limits on all endpoints
14. **Pricing page** — public page with tier comparison, sat/USD toggle
15. **Lightning payments** — SatFlux integration, invoice creation, webhook, subscription activation
16. **Stripe payments** — Checkout session, webhook, subscription management
17. **Billing management UI** — subscription page in settings, usage stats, payment history
18. **Facebook publishing** — Meta Graph API
19. **Instagram publishing** — Meta Graph API (image-required logic)
20. **LinkedIn publishing** — OAuth 2.0 flow
21. **Dashboard** — stats, usage overview, upgrade prompts
22. **Scheduling** — future datetime + cron publish
23. **Media handling improvements** — image resize, preview thumbnails

---

## Key Implementation Notes

- **Multi-user isolation:** EVERY database query must filter by `event.locals.user.id`. Never expose other users' data.
- **Credential encryption:** Platform credentials are encrypted at rest. Decrypt only when publishing.
- Use Drizzle migrations (`npx drizzle-kit push` for dev, `npx drizzle-kit migrate` for production).
- Error handling on every publish attempt — show clear inline error messages per platform.
- Character count should update live in composer and previews, with color coding (green = ok, yellow = near limit, red = over).
- AI adaptation shows loading skeletons while the provider generates.
- "Publish All" uses `Promise.allSettled` — show results as they complete, don't wait for all.
- Instagram toggle auto-disables if no media attached (with tooltip explaining why).
- Platform previews should visually differentiate — each card has the platform's brand color as accent.
- Keep all platform API logic isolated in individual modules — easy to add new platforms later.
- Nostr keypair generation should happen client-side, then nsec sent to server for encrypted storage.
- **Tier enforcement:** Call `checkTierLimit()` before every create/publish/adapt action. Return 403 with upgrade message. Frontend catches 403 and shows a modal with upgrade CTA — never block the user silently.
- **Self-hosted mode:** Check `SELF_HOSTED` env var at startup. If true, skip all billing logic and grant unlimited access. Wrap billing checks in a helper: `if (isSelfHosted()) return { allowed: true }`.
- **Subscription on registration:** New users get `free` tier automatically. Create a `subscriptions` row on registration.
- **Lightning webhook idempotency:** Always check if payment was already processed before activating subscription (invoice hash as idempotency key).
- **Usage counters:** Increment `aiUsage.adaptationsCount` on every successful AI adaptation call. Reset counters are per calendar month (tracked by `month` field in `YYYY-MM` format).

---

## Nice-to-Have (Phase 2)

- Keyboard shortcut: Ctrl+Enter to publish
- Tauri wrapper for native desktop app with tray icon
- Content calendar view (monthly grid)
- Post templates (save reusable post structures)
- Thread support for X (multi-tweet threads) and Bluesky
- Analytics — basic engagement metrics per platform
- Image generation — AI-generated images for posts
- RSS/webhook trigger — auto-post when blog content is published
- Export/import brand profiles
- Team features — invite collaborators to a brand, approval workflow
- Telegram channel publishing
- Threads (Meta) publishing
- OAuth social login (GitHub, Google) via Better Auth plugins
- Admin panel for self-hosted instances (user management, global stats, system config)
- Referral system — existing users invite new users, both get bonus month of Pro
- Usage-based AI billing — instead of flat limit, charge per adaptation above quota (micropayments via Lightning)
- Brand voice prompt marketplace — community-shared prompts with optional paid premium prompts
- Dynamic sat pricing — fetch BTC/USD rate from exchange API at checkout time, cache for 10 minutes
- Stripe customer portal — let users manage payment methods and invoices via Stripe's hosted portal
